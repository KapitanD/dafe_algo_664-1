/*
Идея алгоритма такова - будем хранить для каждого суффикса массива b максимум на этом суффиксе и его индекс,
затем пройдем по массиву а и, т.к. a[i] + mx[i].mx это максимальная сумма с участием элемента а[i], 
найдем максимальную сумму и первые индексы, при которых она проявляется
*/

#include <iostream>
#include <algorithm>

struct maxsuf//структура для хранения максимума и его индекса на суффиксе
{
	int mx = 0, i = 0;
};

maxsuf mx[100013];//сам массив максимума на суффиксе

int main(){
	int n,a[100013], b[100013], i0 = 0, j0 = 0;

	

	std::cin >> n;

	for (int i = 0; i < n; i++)
		std::cin >> a[i];
	for (int i = 0; i < n; i++)
		std::cin >> b[i];

	mx[n - 1].mx = b[n - 1];//база заполнения массива mx
	mx[n - 1].i = n - 1;
	for (int i = n - 2; i >= 0; i--){
		if (b[i] > mx[i + 1].mx){//при нахождении большега числа, меняем текущий максимум
			mx[i].mx = b[i];
			mx[i].i = i;
		}
		else if (b[i] == mx[i + 1].mx){//если число равно текущему максимуму, нужно сменить индекс на индекс этого числа, чтобы сохранялась первоочередность пары индексов ответа
			mx[i].mx = b[i];
			mx[i].i = i;
		}
		else{
			mx[i].mx = mx[i + 1].mx;
			mx[i].i = mx[i + 1].i;
		}
	}
	
	int maxsum = 0;
	for (int i = 0; i < n; i++){//в этом цикле находим максимальную сумму числа из первого массива и максимумма на суффиксе во втором, и сохраняем индексы, при которых сумма максимальна
		if (a[i] + mx[i].mx > maxsum){
			maxsum = a[i] + mx[i].mx;
			i0 = i;
			j0 = mx[i].i;
		}
	}
	
	std::cout << i0 << ' ' << j0;
}
